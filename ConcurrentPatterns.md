# Паттерны конкурентного программирования

Существует множество способов, с помощью которых параллелизм делает нашу
повседневную жизнь проще. Ниже приведены несколько концепций и методологий, 
с помощью которых мы можем сделать программы быстрее и надежнее. <br>

### Генератор

`conc-generator/main.go`

Используя каналы, мы можем достаточно просто реализовать генератор. Так как 
вычисления в генераторе могут являться вычислительно дорогими, то мы могли бы 
сделать генерацию данных конкурентно. Таким образом, программе не нужно ждать, 
пока все данные будут сгенерированы. Например, генерация ряда Фибоначчи.

Используя функцию `fib`, мы получаем канал, который мы можем использовать в цикле. 
Находясь внутри функции fib, мы создаем и возвращаем канал только для приема. 
Возвращаемый канал преобразуется из двунаправленного канала в однонаправленный канал 
для приема. Используя анонимную горутину, мы помещаем числа Фибоначчи в этот канал. 
Как только мы закончили с циклом `for`, мы закрываем канал внутри анонимной горутины. 
В `main`, используя `range`, мы итерируем данные канала, полученные после вызова функции `fib`. <br> <br>


### Fan-in и Fan-out

`conc-fan-in-out/main.go`

Fan-in — это стратегия мультиплексирования, при которой входы нескольких каналов 
объединяются в один выходной канал. Fan-out — это обратная операция, при которой 
один канал разделяется на несколько каналов.

Пройдем по шагам.


1. Получаем канал `chanInputNums`, посредством вызова функции `getInputChan`. 
Функция `getInputChan` создает канал и возвращает его как канал, доступный только 
для чтения, а также запускает анонимную горутину, которая последовательно помещает 
в канал числа из массива `numbers` и закрывает канал. <br> <br>

2. Разделяем наш канал (**fan-out**) 
на два канала(`chanOptSqr1 и chanOptSqr2`), передавая его два раза функции `getSquareChan`. 
Функция `getSquareChan` создает канал и возвращает его как канал, доступный только для чтения, 
а также запускает анонимную горутину для вычисления квадрата чисел на основе данных канала, 
полученного в качестве аргумента функции. <br> <br>

3. Собираем данные из каналов в один (**fan-in**), используя функцию merge. В функции merge мы создаем `WaitGroup`, 
а также новый канал(`merged`), где мы объединим все данные из списка каналов `outputsChan`, после, мы увеличиваем 
счетчик на основании числа полученных каналов, подготавливаем анонимную функцию для чтения данных из канала и 
группировки данных в наш новый канал `merged`, а также уменьшим значение счетчика, когда все данные из переданного 
канала будут считаны. Вызываем нашу анонимную функцию для каждого канала в качестве горутины. А так же создаем и 
стартуем еще одну анонимную горутину для того, чтобы дождаться выполнения операции объединения всех данных в один канал 
и после этого закрываем канал в рамках анонимной функции. После чего возвращаем наш новый канал `merged`. <br> <br>

4. Считываем данные из канала chanMergedSqr используя for и range, и суммируем полученные данные. <br> <br>

5. В конце выводим наш результат.